---
title: 简单哈希查找的实现
categories: 数据结构与算法
tags:
  - 哈希查找 
  - 算法
  - C语言
date: 2018-01-07 16:32:54
---

今天我一时兴起，打算重新看一下哈希查找算法的实现。因为平时用的太多hashTable了，如果连实现原理都不知道，实在是说不过去。
废话不说，开始干货！
<!-- more -->

### 题目描述

>编程实现哈希查找。要求如下：已知哈希表长度为11，哈希函数为H(key) = key % 11,随机产生待散列的小于50的8个元素，
>同时采用线性探测的方法处理哈希冲突。
>任意输入要查找的内容，无论是否找到均给出提示信息。

以下是用C代码的实现：
```
#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#define MAX 11
#define N 8
int hashtable[MAX];

// 自定义函数，返回哈希函数的值。这里实现的是H(key) = key % MAX   
// 返回H(key)
int func(int value)
{
	return value % MAX;

}

// 自定义函数search() 实现哈希查找。 代码如下
// key是要查找的关键字，返回查到的位置
int search(int key) 
{
	int pos,t;         
	pos = func(key);   // 哈希函数确定位置
	t = pos;           // t存放确定出的位置

	// 如果该位置不等于要查找的关键字
	while(hashtable[t] != key && hashtable[t] != -1)
	{
		t = (t + 1) % MAX;  // 利用线性探测求出下一个位置
   
		if (pos == t)
		{
			// 如果经过多次探测又回到原来用哈希函数求出的位置，则说明要查找的数不存在
			return -1;
		}

	}

	if (hashtable[t] == -1)
	{
		return -1;
	} else {
		return t;
	}


}



// 自定义函数 createhash() 实现哈希表的创建。
void createhash(int key)
{
	int pos,t;
	pos = func(key);   // 用哈希函数确定元素的位置
	t = pos;

	while(hashtable[t] != -1)
	{
		t = (t + 1) % MAX;
		
		// 如果冲突处理后确定的位置与原位置相同，则说明哈希表已满
		if (pos == t) {
			printf("哈希表已经满了\n");
		}
	}

	hashtable[t] = key;


}


//  main() 函数作为程序的入口函数
int main()
{
	int flag[50];   // 定义标记变量
	int i,j,t;
	
	// 在哈希表中 初始位置的值都是-1
	for (i = 0; i < MAX; i++)
	{
		
		hashtable[i] = -1;
	}

	// 50以内的所有数未产生时，均标志为0
	for (i = 0; i < 50; i++)
	{
		flag[i] = 0;
	}

	// 利用系统时间做种子产生随机数
	srand((unsigned long) time(0));

	i = 0;
	while(i != N) 
	{
		// 产生一个50以内的随机数赋给t
		t = rand() % 50;

		if (flag[t] == 0)
		{
			// 调用哈希创建函数创建哈希表
			createhash(t);
			// 输出元素
			printf("%2d 哈希表内容如下：", t);

			// 输出哈希表内容
			for (j = 0; j < MAX; j++)
			{
				printf(" %2d ", hashtable[j]);
			}
			printf("\n");
			
			// 标记
			flag[t] = 1;
			i++;
		}
	}


	printf("请输入你想查找的元素：");
	scanf("%d",&t);

	if (t > 0 && t < 50){
	  	i = search(t);
	  	if (i != -1){
	  		printf("查找成功！其位置是：%d\n",i);
	  	} else {
	  		printf("查找失败\n");
	  	}
	} else {
		printf("输入有误！");
	} 


	return 0; 
}


```


代码运行结果如下：
```
34 哈希表内容如下： -1  34  -1  -1  -1  -1  -1  -1  -1  -1  -1
46 哈希表内容如下： -1  34  46  -1  -1  -1  -1  -1  -1  -1  -1
 2 哈希表内容如下： -1  34  46   2  -1  -1  -1  -1  -1  -1  -1
33 哈希表内容如下： 33  34  46   2  -1  -1  -1  -1  -1  -1  -1
25 哈希表内容如下： 33  34  46   2  25  -1  -1  -1  -1  -1  -1
17 哈希表内容如下： 33  34  46   2  25  -1  17  -1  -1  -1  -1
19 哈希表内容如下： 33  34  46   2  25  -1  17  -1  19  -1  -1
32 哈希表内容如下： 33  34  46   2  25  -1  17  -1  19  -1  32
请输入你想查找的元素：32
查找成功！其位置是：10
```

### 要点
哈希函数的构造方法常用的有5中，分别是

- 数字分析法
- 平方取中法
- 分段叠加
- 伪随机数法和余数法

其中余数法比较常用。因为本例实现中已经给出哈希函数所以不必要构造，直接按照题中给的哈希函数来运算即可。
虽然通过构造好的哈希函数可以减少冲突，但是冲突是不可避免的，所以就相应的产生了避免哈希冲突的常用4中方法。分别是：
- 开放地址（包括线性探测再散列和二次探测再散列）
- 链地址法
- 再哈希法
- 建立公共溢出区

开放地址中的线性探测再散列比较常用，该方法的特点是在冲突发生时，顺序查看表中的下一单元，直到找出一个空单元或查遍全表。


### 后话
这个例子只是简单的hash查找的实现，但是原理在其中。通过这个例子可以好好理解哈希实现的原理，让我们在用hashTable的时候，起码知道一些原理。比如我们PHP强大的关联数组。本质上就是一个hashTable。

### 下次博客是啥时候呢？  = =